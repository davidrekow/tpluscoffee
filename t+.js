// Generated by CoffeeScript 1.4.0
(function() {
  var t;

  t = this.t;

  this.t = (function(t) {
    var blocks, extend, includes, load, macro, macros, parse, partial, render, templates, trim, triml, trimr, _macro, _t;
    render = t.prototype.render;
    _t = t;
    t.noConflict = function() {
      t = _t;
      return _t;
    };
    partial = /\{\{\s*?\&\s*?([^\s]+?)\s*?\}\}/g;
    extend = /^\{\{\s*?\^\s*?([^\s]+?)\s*?\}\}\n*?([.\n]*)/;
    _macro = /\{\{\s*?(\+\s*?([^\(]+))\(([^\)]*)\)\s*?\}\}(?:([\s\S.]+)\{\{\s*?\/\s*?(?:\1|\2)\}\})?/g;
    blocks = /\{\{\s*?(#\s*?([\w]+))\s*?\}\}([\s\S.]*)\{\{\s*?\/\s*?(?:\1|\2)\}\}/g;
    triml = /^\s+/;
    trimr = /\s+$/;
    trim = function(str) {
      var i, s, _i, _len;
      if (str.charAt) {
        str = str.replace(triml, '').replace(trimr, '');
      } else if (str.length) {
        for (i = _i = 0, _len = str.length; _i < _len; i = ++_i) {
          s = str[i];
          str[i] = trim(s);
        }
      }
      return str;
    };
    templates = {};
    load = function(name, tpl, callback) {
      var count, len, results, _i, _len, _name, _tpl;
      if (!name) {
        return templates;
      }
      if (!callback) {
        if (typeof tpl === 'function') {
          callback = tpl;
          tpl = null;
        } else {
          tpl = tpl.t ? tpl : new t(tpl);
          tpl.name = name;
          templates[name] = tpl;
          return;
        }
      }
      if (typeof name === 'object') {
        for (_name in name) {
          _tpl = name[_name];
          load(_name, _tpl);
        }
        return callback && callback();
      }
      if (name.length && name.slice && !name.split) {
        len = name.length;
        results = {};
        count = 0;
        for (_i = 0, _len = name.length; _i < _len; _i++) {
          _name = name[_i];
          load(_name, function(_tpl) {
            results[_name] = _tpl;
            if (++count === len) {
              return callback && callback(results);
            }
          });
        }
        return;
      }
      return callback && callback(templates[name]);
    };
    macros = {};
    macro = function(name, fn, ctx) {
      var _fn, _name;
      if (ctx == null) {
        ctx = null;
      }
      if (!name) {
        return macros;
      }
      if (typeof name === 'object') {
        ctx = fn || ctx;
        for (_name in name) {
          _fn = name[_name];
          macro(_name, _fn, ctx);
        }
        return;
      }
      if (fn && typeof fn === 'function') {
        macros[name] = function() {
          return fn.apply(ctx, arguments);
        };
      }
      return macros[name];
    };
    includes = function(tpl, vars, cb) {
      var hasParts, match, name, parts;
      if (!(tpl && vars)) {
        return false;
      }
      if (!cb) {
        cb = vars;
        vars = {};
      }
      parts = [];
      hasParts = partial.exec(tpl.t);
      while (hasParts) {
        match = hasParts[0], name = hasParts[1];
        parts.push(name);
        hasParts = partial.exec(tpl.t);
      }
      if (parts.length) {
        return tpl.load(parts, function(partials) {
          var src;
          src = tpl.t;
          tpl.t = src.replace(partial, function(_, name) {
            var e, part;
            if (partials[name]) {
              part = partials[name];
              if (!extend.test(part.t)) {
                return part.t;
              }
              e = new Error('[t+]: Invalid include: ' + name + '. Includes may not contain extend blocks.');
              return cb && cb(false, e);
            } else {
              return _;
            }
          });
          return includes(tpl, vars, cb);
        });
      } else {
        tpl.parsed = tpl.t;
        return parse(tpl, vars, false, cb);
      }
    };
    parse = function(tpl, vars, refresh, cb) {
      var hasParent, html, match, name, rest, src;
      src = tpl.t;
      if (refresh || !tpl.parsed) {
        tpl.parsed = null;
        hasParent = extend.exec(src);
        if (!hasParent) {
          return includes(tpl, vars, cb);
        }
        match = hasParent[0], name = hasParent[1], rest = hasParent[2];
        return tpl.load(name, function(parent) {
          var content, hasBlocks, tag, _blocks;
          tpl.t = parent.t;
          _blocks = {};
          hasBlocks = blocks.exec(src);
          while (hasBlocks) {
            match = hasBlocks[0], tag = hasBlocks[1], name = hasBlocks[2], content = hasBlocks[3];
            _blocks[name] = content;
            hasBlocks = blocks.exec(src);
          }
          tpl.t = tpl.t.replace(blocks, function(_, __, $name, inner) {
            return _blocks[$name] || inner;
          });
          return includes(tpl, vars, cb);
        });
      } else {
        tpl.t = tpl.parsed;
      }
      html = render.call(tpl, vars).replace(macro, function(_, __, name, params, content) {
        var args, m, param, _i, _len;
        params = trim(params.split(','));
        content = content || '';
        m = tpl.macro(name);
        if (m) {
          args = [];
          for (_i = 0, _len = params.length; _i < _len; _i++) {
            param = params[_i];
            args.push(vars[param]);
          }
          try {
            return m.apply(null, args);
          } catch (e) {
            console.log('[t+] Macro error:', e);
          }
        } else {
          console.log('[t+] No macro found:', name);
        }
        return content;
      });
      tpl.t = src;
      return cb && cb(html);
    };
    t.load = t.prototype.load = function(name, callback) {
      return load(name, null, callback);
    };
    t.put = t.prototype.put = function(name, tpl, callback) {
      return load(name, tpl, callback);
    };
    t.macro = t.prototype.macro = function(name, fn) {
      return macro(name, fn);
    };
    t.prototype.render = function(vars, callback, refresh) {
      if (refresh == null) {
        refresh = false;
      }
      return parse(this, vars, refresh, callback);
    };
    return t;
  })(t);

}).call(this);
